<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Comic Vault - Simple Collection Manager</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet" />
  <style>
    :root {
      --bg: #0b0d12;
      --panel: #141824;
      --panel-2: #1b2131;
      --panel-3: #0f1420;
      --accent: #ff5c3a;
      --accent-2: #ffe082;
      --accent-3: #8ad3ff;
      --text: #f4f6fb;
      --muted: #9aa4b2;
      --good: #42d392;
      --bad: #ff6b6b;
      --border: #2a3144;
      --shadow: 0 20px 50px rgba(0,0,0,0.35);
      --radius: 16px;
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Space Grotesk", sans-serif;
      color: var(--text);
      background:
        radial-gradient(1200px 800px at 12% -20%, rgba(255,92,58,0.2), transparent 60%),
        radial-gradient(1000px 700px at 100% 0%, rgba(138,211,255,0.14), transparent 55%),
        radial-gradient(900px 900px at 50% 120%, rgba(255,224,130,0.12), transparent 60%),
        linear-gradient(180deg, #0a0d14 0%, #101622 100%);
      min-height: 100vh;
    }

    header {
      padding: 28px 24px 16px;
      display: flex;
      gap: 24px;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
    }

    .brand {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .title {
      font-size: 30px;
      font-weight: 700;
      letter-spacing: 0.5px;
    }

    .subtitle {
      color: var(--muted);
      font-size: 14px;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 18px;
      padding: 0 24px 24px;
    }

    .card {
      background: linear-gradient(150deg, rgba(255,255,255,0.04), rgba(255,255,255,0.01));
      background-color: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 18px;
      box-shadow: var(--shadow);
    }

    .collection-card {
      grid-column: 1 / -1;
      background: linear-gradient(140deg, rgba(255,92,58,0.14), rgba(15,20,32,0.8));
      border-color: rgba(255,255,255,0.14);
    }

    .card h2 {
      margin: 0 0 12px;
      font-size: 18px;
      font-weight: 600;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-bottom: 12px;
    }

    label {
      font-size: 12px;
      color: var(--muted);
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    input, textarea, select {
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--panel-2);
      color: var(--text);
      font-family: inherit;
      font-size: 14px;
    }

    textarea { min-height: 80px; resize: vertical; }

    button {
      background: var(--accent);
      border: none;
      color: #0b0d12;
      font-weight: 700;
      padding: 10px 16px;
      border-radius: 12px;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease, filter 0.15s ease;
    }

    button.secondary {
      background: transparent;
      color: var(--text);
      border: 1px solid var(--border);
    }

    button:active { transform: translateY(1px); }

    .row {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    .status {
      font-family: "IBM Plex Mono", monospace;
      font-size: 12px;
      color: var(--muted);
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.07);
      color: var(--muted);
      font-size: 12px;
    }

    .results, .collection {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
      max-height: 420px;
      overflow: auto;
      padding-right: 6px;
    }

    .comic {
      background: linear-gradient(180deg, rgba(15,20,32,0.9), rgba(10,13,20,0.95));
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      display: grid;
      grid-template-columns: 90px 1fr;
      gap: 10px;
      transition: transform 0.18s ease, border-color 0.18s ease;
    }

    .comic img {
      width: 90px;
      height: 130px;
      object-fit: cover;
      border-radius: 8px;
      border: 1px solid var(--border);
    }

    .collection .comic {
      grid-template-columns: 60px 1fr;
    }

    .collection .comic img {
      width: 60px;
      height: 88px;
      cursor: pointer;
      box-shadow: 0 10px 20px rgba(0,0,0,0.35);
    }

    .comic h3 {
      margin: 0 0 6px;
      font-size: 14px;
    }

    .comic p {
      margin: 0;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.4;
    }

    .comic .synopsis {
      margin-top: 6px;
      color: #c6cfde;
      font-size: 12px;
      line-height: 1.45;
    }

    .comic:hover {
      transform: translateY(-2px);
      border-color: rgba(255,255,255,0.18);
    }

    .modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 50;
    }

    .modal.active { display: flex; }

    .modal-backdrop {
      position: absolute;
      inset: 0;
      background: rgba(6,8,12,0.75);
      backdrop-filter: blur(6px);
    }

    .modal-card {
      position: relative;
      z-index: 2;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 18px;
      width: min(900px, 92vw);
      box-shadow: var(--shadow);
    }

    .modal-content {
      display: grid;
      grid-template-columns: 240px 1fr;
      gap: 18px;
      margin-top: 12px;
    }

    .modal-content img {
      width: 100%;
      border-radius: 12px;
      border: 1px solid var(--border);
    }

    @media (max-width: 720px) {
      .modal-content {
        grid-template-columns: 1fr;
      }
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 10px;
    }

    .stat {
      background: #111624;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
    }

    .stat .value {
      font-size: 20px;
      font-weight: 700;
    }

    .muted { color: var(--muted); }
    .good { color: var(--good); }
    .bad { color: var(--bad); }

    footer {
      padding: 0 24px 32px;
      color: var(--muted);
      font-size: 12px;
    }

    @media (max-width: 720px) {
      header { padding: 20px 18px 10px; }
      .grid { padding: 0 18px 18px; }
    }
  </style>
</head>
<body>
  <header>
    <div class="brand">
      <div class="title">Comic Vault</div>
      <div class="subtitle">Single-file comic collection manager. No backend, no hassle.</div>
    </div>
    <div class="row">
      <span class="badge">Local storage</span>
      <span class="badge">ComicVine API</span>
      <span class="badge">CSV import/export</span>
    </div>
  </header>

  <main class="grid">
    <section class="card collection-card">
      <div class="row" style="justify-content: space-between; align-items: flex-end;">
        <div>
          <h2 style="margin-bottom:4px;">Your Collection</h2>
          <p class="muted" style="margin:0;">Tap a cover to open a full synopsis + large cover.</p>
        </div>
        <div class="row">
          <button id="enrichBtn" class="secondary">Enrich Missing</button>
          <button id="enrichAllBtn" class="secondary">Enrich All (Batch)</button>
        </div>
      </div>
      <div class="row" style="margin-top:10px;">
        <button id="exportCsv">Export CSV</button>
        <button id="clearCollection" class="secondary">Clear Collection</button>
      </div>
      <p class="status" id="enrichStatus">Ready.</p>
      <div class="collection" id="collection"></div>
    </section>

    <section class="card">
      <h2>API Setup</h2>
      <div class="field">
        <label for="apiKey">ComicVine API Key</label>
        <input id="apiKey" placeholder="Paste your API key" />
      </div>
      <div class="row">
        <button id="saveKey">Save Key</button>
        <button id="clearKey" class="secondary">Clear Key</button>
      </div>
      <p class="status" id="apiStatus">Waiting for API key.</p>
      <p class="muted">No API URL needed. This uses the ComicVine API through a CORS proxy automatically.</p>
    </section>

    <section class="card">
      <h2>Search ComicVine</h2>
      <div class="field">
        <label for="query">Search</label>
        <input id="query" placeholder="Batman, X-Men, Saga..." />
      </div>
      <div class="row">
        <button id="searchBtn">Search Issues</button>
        <button id="clearSearch" class="secondary">Clear</button>
      </div>
      <p class="status" id="searchStatus">Ready.</p>
      <div class="results" id="results"></div>
    </section>

    <section class="card">
      <h2>Import CSV</h2>
      <div class="field">
        <label for="csvInput">CSV File</label>
        <input id="csvInput" type="file" accept=".csv" />
      </div>
      <div class="field">
        <label for="csvPreview">Detected Columns</label>
        <textarea id="csvPreview" readonly></textarea>
      </div>
      <div class="row">
        <button id="importCsv">Import</button>
        <button id="resetImport" class="secondary">Reset</button>
      </div>
      <p class="status" id="importStatus">Waiting for CSV.</p>
    </section>

    <section class="card">
      <h2>Stats</h2>
      <div class="stats" id="stats"></div>
    </section>
  </main>

  <div class="modal" id="detailModal" aria-hidden="true">
    <div class="modal-backdrop" data-close="true"></div>
    <div class="modal-card">
      <div class="row" style="justify-content: space-between; align-items: center;">
        <div class="title" style="font-size:20px;">Comic Details</div>
        <button id="closeModal" class="secondary">Close</button>
      </div>
      <div class="modal-content">
        <img id="detailCover" alt="Cover" />
        <div>
          <h3 id="detailTitle" style="margin-top:0;"></h3>
          <p class="muted" id="detailIssue"></p>
          <p class="muted" id="detailDate"></p>
          <p id="detailSynopsis" class="synopsis" style="margin-top:10px;"></p>
          <div class="field" style="margin-top:12px;">
            <label for="fixQuery">Fix Cover (Search)</label>
            <input id="fixQuery" placeholder="Search ComicVine for correct issue" />
          </div>
          <div class="row">
            <button id="fixSearchBtn" class="secondary">Search</button>
          </div>
          <div class="results" id="fixResults" style="margin-top:10px; max-height:240px;"></div>
        </div>
      </div>
    </div>
  </div>

  <footer>
    Built to keep it simple. Data is stored only in your browser (localStorage).
  </footer>

  <script>
    const storage = {
      get(key, fallback) {
        try {
          const raw = localStorage.getItem(key);
          return raw ? JSON.parse(raw) : fallback;
        } catch {
          return fallback;
        }
      },
      set(key, value) {
        localStorage.setItem(key, JSON.stringify(value));
      },
      remove(key) {
        localStorage.removeItem(key);
      }
    };

    const state = {
      apiKey: storage.get("cv_api_key", ""),
      collection: storage.get("cv_collection_v1", []),
      csvRows: [],
      csvHeaders: [],
      activeIndex: null
    };

    const els = {
      apiKey: document.getElementById("apiKey"),
      apiStatus: document.getElementById("apiStatus"),
      saveKey: document.getElementById("saveKey"),
      clearKey: document.getElementById("clearKey"),
      query: document.getElementById("query"),
      searchBtn: document.getElementById("searchBtn"),
      clearSearch: document.getElementById("clearSearch"),
      results: document.getElementById("results"),
      searchStatus: document.getElementById("searchStatus"),
      collection: document.getElementById("collection"),
      enrichBtn: document.getElementById("enrichBtn"),
      enrichAllBtn: document.getElementById("enrichAllBtn"),
      enrichStatus: document.getElementById("enrichStatus"),
      exportCsv: document.getElementById("exportCsv"),
      clearCollection: document.getElementById("clearCollection"),
      csvInput: document.getElementById("csvInput"),
      csvPreview: document.getElementById("csvPreview"),
      importCsv: document.getElementById("importCsv"),
      resetImport: document.getElementById("resetImport"),
      importStatus: document.getElementById("importStatus"),
      stats: document.getElementById("stats"),
      detailModal: document.getElementById("detailModal"),
      closeModal: document.getElementById("closeModal"),
      detailCover: document.getElementById("detailCover"),
      detailTitle: document.getElementById("detailTitle"),
      detailIssue: document.getElementById("detailIssue"),
      detailDate: document.getElementById("detailDate"),
      detailSynopsis: document.getElementById("detailSynopsis"),
      fixQuery: document.getElementById("fixQuery"),
      fixSearchBtn: document.getElementById("fixSearchBtn"),
      fixResults: document.getElementById("fixResults")
    };

    els.apiKey.value = state.apiKey;
    updateApiStatus();
    renderCollection();
    renderStats();

    els.saveKey.addEventListener("click", () => {
      state.apiKey = els.apiKey.value.trim();
      storage.set("cv_api_key", state.apiKey);
      updateApiStatus();
    });

    els.clearKey.addEventListener("click", () => {
      state.apiKey = "";
      els.apiKey.value = "";
      storage.remove("cv_api_key");
      updateApiStatus();
    });

    els.searchBtn.addEventListener("click", () => searchIssues());
    els.clearSearch.addEventListener("click", () => {
      els.query.value = "";
      els.results.innerHTML = "";
      els.searchStatus.textContent = "Cleared.";
    });

    els.exportCsv.addEventListener("click", () => exportCsv());
    els.clearCollection.addEventListener("click", () => {
      if (!confirm("Clear your entire collection?")) return;
      state.collection = [];
      storage.set("cv_collection_v1", state.collection);
      renderCollection();
      renderStats();
    });
    els.enrichBtn.addEventListener("click", () => enrichCollection());
    els.enrichAllBtn.addEventListener("click", () => enrichAllBatches());

    els.csvInput.addEventListener("change", handleCsvFile);
    els.importCsv.addEventListener("click", importCsv);
    els.resetImport.addEventListener("click", () => {
      els.csvInput.value = "";
      els.csvPreview.value = "";
      state.csvRows = [];
      state.csvHeaders = [];
      els.importStatus.textContent = "Waiting for CSV.";
    });

    els.closeModal.addEventListener("click", closeModal);
    els.detailModal.addEventListener("click", (event) => {
      if (event.target.dataset.close) closeModal();
    });
    els.fixSearchBtn.addEventListener("click", () => searchFixResults());

    async function searchIssues() {
      if (!state.apiKey) {
        els.searchStatus.textContent = "Add your ComicVine API key first.";
        return;
      }
      const query = els.query.value.trim();
      if (!query) {
        els.searchStatus.textContent = "Enter a search term.";
        return;
      }

      els.searchStatus.textContent = "Searching...";
      els.results.innerHTML = "";

      try {
        const res = await fetchComicVine("/search/", {
          api_key: state.apiKey,
          format: "json",
          resources: "issue",
          query,
          limit: "20",
          field_list: "id,name,issue_number,cover_date,image,volume,description"
        });
        const data = await res.json();
        if (data.error && data.error !== "OK") {
          throw new Error(data.error);
        }
        const results = data.results || [];
        if (!results.length) {
          els.searchStatus.textContent = "No results.";
          return;
        }
        els.searchStatus.textContent = `Found ${results.length} issues.`;
        renderResults(results);
      } catch (err) {
        els.searchStatus.textContent = `Search failed: ${err.message}`;
      }
    }

    function renderResults(results) {
      els.results.innerHTML = "";
      results.forEach((item) => {
        const card = document.createElement("div");
        card.className = "comic";
        const img = item.image?.small_url || "";
        const synopsis = truncate(stripHtml(item.description || ""), 140);
        card.innerHTML = `
          <img src="${img}" alt="${escapeHtml(item.name || "Issue")}" />
          <div>
            <h3>${escapeHtml(item.volume?.name || item.name || "Unknown")}</h3>
            <p>Issue #${escapeHtml(item.issue_number || "?")}</p>
            <p>${escapeHtml(item.cover_date || "")}</p>
            <p class="synopsis">${synopsis ? `Synopsis: ${escapeHtml(synopsis)}` : "Synopsis: -"} </p>
            <div class="row" style="margin-top:8px;">
              <button data-add="${item.id}">Add</button>
            </div>
          </div>
        `;
        card.querySelector("button").addEventListener("click", () => addToCollection(item));
        els.results.appendChild(card);
      });
    }

    function addToCollection(item) {
      const exists = state.collection.some((c) => c.id === item.id);
      if (exists) {
        els.searchStatus.textContent = "Already in collection.";
        return;
      }
      const entry = {
        id: item.id,
        series: item.volume?.name || item.name || "Unknown",
        issue: item.issue_number || "",
        coverDate: item.cover_date || "",
        image: item.image?.small_url || "",
        synopsis: stripHtml(item.description || ""),
        notes: ""
      };
      state.collection.unshift(entry);
      storage.set("cv_collection_v1", state.collection);
      renderCollection();
      renderStats();
      els.searchStatus.textContent = "Added to collection.";
    }

    function renderCollection() {
      els.collection.innerHTML = "";
      if (!state.collection.length) {
        els.collection.innerHTML = "<p class='muted'>No comics yet.</p>";
        return;
      }
      state.collection.forEach((item, index) => {
        const synopsis = truncate(item.synopsis || item.notes || "", 140);
        const card = document.createElement("div");
        card.className = "comic";
        card.innerHTML = `
          <img src="${item.image || ""}" alt="${escapeHtml(item.series)}" />
          <div>
            <h3>${escapeHtml(item.series)}</h3>
            <p>Issue #${escapeHtml(item.issue || "?")}</p>
            <p>${escapeHtml(item.coverDate || "")}</p>
            <p class="synopsis">${synopsis ? `Synopsis: ${escapeHtml(synopsis)}` : "Synopsis: -"} </p>
            <div class="row" style="margin-top:8px;">
              <button data-remove="${index}" class="secondary">Remove</button>
            </div>
          </div>
        `;
        card.querySelector("img").addEventListener("click", () => openModal(item));
        card.querySelector("button").addEventListener("click", () => {
          state.collection.splice(index, 1);
          storage.set("cv_collection_v1", state.collection);
          renderCollection();
          renderStats();
        });
        els.collection.appendChild(card);
      });
    }

    function renderStats() {
      const total = state.collection.length;
      const seriesSet = new Set(state.collection.map((c) => c.series));
      const years = state.collection
        .map((c) => (c.coverDate || "").slice(0, 4))
        .filter((y) => y && /^\d{4}$/.test(y));
      const yearCounts = years.reduce((acc, y) => {
        acc[y] = (acc[y] || 0) + 1;
        return acc;
      }, {});
      const topYear = Object.entries(yearCounts).sort((a, b) => b[1] - a[1])[0];

      els.stats.innerHTML = "";
      const statItems = [
        { label: "Total Issues", value: total },
        { label: "Series", value: seriesSet.size },
        { label: "Top Year", value: topYear ? `${topYear[0]} (${topYear[1]})` : "-" }
      ];

      statItems.forEach((stat) => {
        const div = document.createElement("div");
        div.className = "stat";
        div.innerHTML = `<div class="muted">${stat.label}</div><div class="value">${stat.value}</div>`;
        els.stats.appendChild(div);
      });
    }

    function updateApiStatus() {
      if (state.apiKey) {
        els.apiStatus.textContent = "API key saved.";
        els.apiStatus.className = "status good";
      } else {
        els.apiStatus.textContent = "Waiting for API key.";
        els.apiStatus.className = "status";
      }
    }

    function openModal(item) {
      state.activeIndex = state.collection.findIndex((c) => c.id === item.id);
      els.detailCover.src = item.image || "";
      els.detailTitle.textContent = item.series || "Unknown";
      els.detailIssue.textContent = `Issue #${item.issue || "?"}`;
      els.detailDate.textContent = item.coverDate || "";
      const fullSynopsis = item.synopsis || item.notes || "No synopsis available.";
      els.detailSynopsis.textContent = fullSynopsis;
      els.fixQuery.value = `${item.series || ""} ${item.issue || ""}`.trim();
      els.fixResults.innerHTML = "";
      els.detailModal.classList.add("active");
      els.detailModal.setAttribute("aria-hidden", "false");
    }

    function closeModal() {
      els.detailModal.classList.remove("active");
      els.detailModal.setAttribute("aria-hidden", "true");
    }

    async function searchFixResults() {
      if (!state.apiKey) {
        els.enrichStatus.textContent = "Add your ComicVine API key first.";
        return;
      }
      const query = els.fixQuery.value.trim();
      if (!query) return;

      els.fixResults.innerHTML = "<p class='muted'>Searching...</p>";
      try {
        const res = await fetchComicVine("/search/", {
          api_key: state.apiKey,
          format: "json",
          resources: "issue",
          query,
          limit: "10",
          field_list: "name,issue_number,cover_date,image,volume,description"
        });
        const data = await res.json();
        if (data.error && data.error !== "OK") {
          throw new Error(data.error);
        }
        renderFixResults(data.results || []);
      } catch (err) {
        els.fixResults.innerHTML = `<p class='bad'>Search failed: ${err.message}</p>`;
      }
    }

    function renderFixResults(results) {
      if (!results.length) {
        els.fixResults.innerHTML = "<p class='muted'>No results.</p>";
        return;
      }
      els.fixResults.innerHTML = "";
      results.forEach((item) => {
        const card = document.createElement("div");
        card.className = "comic";
        const img = item.image?.small_url || "";
        card.innerHTML = `
          <img src="${img}" alt="${escapeHtml(item.name || "Issue")}" />
          <div>
            <h3>${escapeHtml(item.volume?.name || item.name || "Unknown")}</h3>
            <p>Issue #${escapeHtml(item.issue_number || "?")}</p>
            <p>${escapeHtml(item.cover_date || "")}</p>
            <div class="row" style="margin-top:8px;">
              <button data-pick="true">Use This</button>
            </div>
          </div>
        `;
        card.querySelector("button").addEventListener("click", () => applyFixResult(item));
        els.fixResults.appendChild(card);
      });
    }

    function applyFixResult(item) {
      if (state.activeIndex == null || state.activeIndex < 0) return;
      const current = state.collection[state.activeIndex];
      state.collection[state.activeIndex] = {
        ...current,
        image: item.image?.small_url || current.image || "",
        coverDate: item.cover_date || current.coverDate || "",
        synopsis: stripHtml(item.description || "") || current.synopsis || ""
      };
      storage.set("cv_collection_v1", state.collection);
      renderCollection();
      renderStats();
      openModal(state.collection[state.activeIndex]);
    }

    async function fetchComicVine(path, params) {
      const base = "https://comicvine.gamespot.com/api";
      const url = `${base}${path}?${new URLSearchParams(params).toString()}`;
      const proxies = [
        (u) => `https://corsproxy.io/?${encodeURIComponent(u)}`,
        (u) => `https://api.allorigins.win/raw?url=${encodeURIComponent(u)}`,
        (u) => `https://thingproxy.freeboard.io/fetch/${u}`,
        (u) => `https://cors.isomorphic-git.org/${u}`
      ];

      let lastError = "Unknown error";
      for (const makeUrl of proxies) {
        const proxyUrl = makeUrl(url);
        try {
          const res = await fetch(proxyUrl);
          if (res.ok) return res;
          const text = await res.text().catch(() => "");
          if (text.includes("corsproxy.io") || res.status === 403) {
            lastError = "Proxy blocked";
            continue;
          }
          lastError = `HTTP ${res.status}`;
        } catch (err) {
          lastError = err.message || "Network error";
        }
      }
      throw new Error(`All proxies failed (${lastError}). Try again later.`);
    }

    async function enrichCollection() {
      if (!state.apiKey) {
        els.enrichStatus.textContent = "Add your ComicVine API key first.";
        return;
      }

      const toEnrich = state.collection
        .map((item, index) => ({ item, index }))
        .filter(({ item }) => !item.synopsis || !item.image);

      if (!toEnrich.length) {
        els.enrichStatus.textContent = "Nothing to enrich.";
        return;
      }

      const maxBatch = 25;
      const batch = toEnrich.slice(0, maxBatch);
      const remaining = toEnrich.length - batch.length;
      els.enrichBtn.disabled = true;
      els.enrichAllBtn.disabled = true;
      let enriched = 0;
      let skipped = 0;
      let noMatch = 0;

      for (const entry of batch) {
        const { item, index } = entry;
        els.enrichStatus.textContent = `Enriching ${enriched + skipped + noMatch + 1} / ${batch.length}...`;
        try {
          const found = await findIssueMatch(item);
          if (found) {
            const foundYear = extractYear(found.cover_date || "");
            const currentYear = extractYear(item.coverDate || "");
            if (currentYear && foundYear && Math.abs(foundYear - currentYear) > 5) {
              noMatch += 1;
              continue;
            }
            state.collection[index] = {
              ...item,
              image: item.image || found.image?.small_url || "",
              coverDate: (!currentYear || (foundYear && Math.abs(foundYear - currentYear) > 5))
                ? (found.cover_date || item.coverDate || "")
                : item.coverDate,
              synopsis: item.synopsis || stripHtml(found.description || "")
            };
            enriched += 1;
          } else {
            noMatch += 1;
          }
        } catch (err) {
          if (String(err.message).includes("rate limit")) {
            els.enrichStatus.textContent = "Hit API limit. Waiting 60s...";
            await delay(60000);
          } else {
            skipped += 1;
            els.enrichStatus.textContent = `Enrich error: ${err.message}`;
          }
        }

        await delay(1200);
      }

      storage.set("cv_collection_v1", state.collection);
      renderCollection();
      renderStats();
      const more = remaining > 0 ? ` ${remaining} left, run again.` : "";
      els.enrichStatus.textContent = `Enriched ${enriched}. No match ${noMatch}. Errors ${skipped}.${more}`;
      els.enrichBtn.disabled = false;
      els.enrichAllBtn.disabled = false;
    }

    function delay(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }

    async function enrichAllBatches() {
      if (!state.apiKey) {
        els.enrichStatus.textContent = "Add your ComicVine API key first.";
        return;
      }
      els.enrichAllBtn.disabled = true;
      let totalRemaining = state.collection.filter((item) => !item.synopsis || !item.image).length;
      let batchCount = 0;

      while (totalRemaining > 0) {
        batchCount += 1;
        els.enrichStatus.textContent = `Batch ${batchCount} running...`;
        await enrichCollection();
        totalRemaining = state.collection.filter((item) => !item.synopsis || !item.image).length;
        if (totalRemaining > 0) {
          els.enrichStatus.textContent = `Batch ${batchCount} done. Waiting 3s...`;
          await delay(3000);
        }
      }

      els.enrichStatus.textContent = "All batches complete.";
      els.enrichAllBtn.disabled = false;
    }

    const volumeCache = new Map();

    async function findIssueMatch(item) {
      const seriesName = (item.series || "").trim();
      const issueNumber = (item.issue || "").trim();
      if (!seriesName || !issueNumber) return null;

      const volume = await findVolumeMatch(seriesName, item.coverDate || "");
      if (volume) {
        const byVolume = await findIssueByVolume(volume, issueNumber);
        if (byVolume) return byVolume;
      }

      const queryFull = `${seriesName} ${issueNumber}`.trim();
      const querySeries = `${seriesName}`.trim();
      const params = {
        api_key: state.apiKey,
        format: "json",
        resources: "issue",
        limit: "10",
        field_list: "name,issue_number,cover_date,image,volume,description"
      };

      const tryQuery = async (query) => {
        if (!query) return null;
        const res = await fetchComicVine("/search/", { ...params, query });
        const data = await res.json();
        if (data.error && data.error !== "OK") {
          throw new Error(data.error);
        }
        const results = data.results || [];
        return pickBestMatch(item, results);
      };

      const bestFull = await tryQuery(queryFull);
      if (bestFull) return bestFull;
      const bestSeries = await tryQuery(querySeries);
      if (bestSeries) return bestSeries;
      return null;
    }

    async function findVolumeMatch(seriesName, coverDate) {
      const cacheKey = `${seriesName}::${coverDate || ""}`;
      if (volumeCache.has(cacheKey)) return volumeCache.get(cacheKey);

      const cleanedSeries = stripVolumeSuffix(seriesName);
      const res = await fetchComicVine("/search/", {
        api_key: state.apiKey,
        format: "json",
        resources: "volume",
        query: cleanedSeries || seriesName,
        limit: "10",
        field_list: "id,name,start_year,publisher"
      });
      const data = await res.json();
      if (data.error && data.error !== "OK") {
        throw new Error(data.error);
      }
      const results = data.results || [];
      const best = pickBestVolume(seriesName, coverDate, results);
      volumeCache.set(cacheKey, best);
      return best;
    }

    async function findIssueByVolume(volume, issueNumber) {
      if (!volume || !volume.id) return null;
      const issueKey = normalizeIssue(issueNumber);
      const variants = uniqueIssueVariants(issueNumber);

      for (const variant of variants) {
        const res = await fetchComicVine("/issues/", {
          api_key: state.apiKey,
          format: "json",
          filter: `volume:${volume.id},issue_number:${variant}`,
          field_list: "name,issue_number,cover_date,image,volume,description",
          limit: "5"
        });
        const data = await res.json();
        if (data.error && data.error !== "OK") {
          throw new Error(data.error);
        }
        const results = data.results || [];
        if (results.length) {
          const exact = results.find((r) => normalizeIssue(r.issue_number || "") === issueKey);
          return exact || null;
        }
      }

      return null;
    }

    function pickBestMatch(item, results) {
      if (!results.length) return null;
      const targetSeries = normalizeSeries(item.series || "");
      const targetIssue = normalizeIssue(item.issue || "");
      let best = null;
      let bestScore = -1;

      for (const r of results) {
        const series = normalizeSeries(r.volume?.name || r.name || "");
        const issue = normalizeIssue(r.issue_number || "");
        let score = 0;

        if (series === targetSeries) score += 8;
        if (issue && issue === targetIssue) score += 8;
        if (series.includes(targetSeries) || targetSeries.includes(series)) score += 2;
        if (issue && targetIssue && (issue.startsWith(targetIssue) || targetIssue.startsWith(issue))) score += 2;

        if (score > bestScore) {
          bestScore = score;
          best = r;
        }
      }

      return bestScore >= 8 ? best : null;
    }

    function pickBestVolume(seriesName, coverDate, results) {
      if (!results.length) return null;
      const targetSeries = normalizeSeries(seriesName);
      const targetYear = extractYear(coverDate);
      const targetVol = extractVolumeNumber(seriesName);
      let best = null;
      let bestScore = -1;

      const ordered = [...results].sort((a, b) => {
        const aYear = Number(a.start_year || 9999);
        const bYear = Number(b.start_year || 9999);
        return aYear - bYear;
      });

      for (const [index, r] of ordered.entries()) {
        const series = normalizeSeries(r.name || "");
        let score = 0;
        if (series === targetSeries) score += 8;
        if (series.includes(targetSeries) || targetSeries.includes(series)) score += 2;
        if (targetVol) {
          const expectedIndex = targetVol - 1;
          if (expectedIndex === index) score += 4;
          else if (Math.abs(expectedIndex - index) === 1) score += 2;
        }
        if (targetYear && r.start_year) {
          const diff = Math.abs(Number(r.start_year) - targetYear);
          if (diff <= 1) score += 3;
          else if (diff <= 3) score += 2;
          else if (diff <= 5) score += 1;
          else if (diff >= 15) score -= 2;
        }
        if (score > bestScore) {
          bestScore = score;
          best = r;
        }
      }

      return bestScore >= 6 ? best : null;
    }

    function normalizeSeries(value) {
      return String(value)
        .toLowerCase()
        .replace(/\bvol\.?\s*\d+\b/g, "")
        .replace(/\([^)]*\)/g, "")
        .replace(/[^a-z0-9]+/g, " ")
        .trim();
    }

    function normalizeIssue(value) {
      return String(value)
        .toLowerCase()
        .replace(/[^0-9a-z]+/g, "")
        .trim();
    }

    function uniqueIssueVariants(value) {
      const raw = String(value || "").trim();
      const normalized = normalizeIssue(raw);
      const numeric = normalized.replace(/[a-z]+/g, "");
      const variants = [raw, normalized, numeric].filter((v) => v && v.length);
      return Array.from(new Set(variants));
    }

    function stripVolumeSuffix(value) {
      return String(value || "").replace(/\bvol\.?\s*\d+\b/ig, "").trim();
    }

    function extractVolumeNumber(value) {
      const match = String(value || "").match(/\bvol\.?\s*(\d+)\b/i);
      return match ? Number(match[1]) : null;
    }

    function extractYear(value) {
      const year = Number(String(value || "").slice(0, 4));
      if (year >= 1930 && year <= new Date().getFullYear()) return year;
      return null;
    }

    function handleCsvFile(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = () => {
        const text = reader.result;
        const { headers, rows } = parseCsv(text);
        state.csvHeaders = headers;
        state.csvRows = rows;
        els.csvPreview.value = headers.length ? headers.join(", ") : "No headers detected.";
        els.importStatus.textContent = `Loaded ${rows.length} rows.`;
      };
      reader.readAsText(file);
    }

    function importCsv() {
      if (!state.csvRows.length) {
        els.importStatus.textContent = "Load a CSV file first.";
        return;
      }

      const mapping = mapHeaders(state.csvHeaders);
      if (!mapping.series || !mapping.issue) {
        els.importStatus.textContent = "CSV needs columns for Series/Title and Issue.";
        return;
      }

      let added = 0;
      let skipped = 0;

      state.csvRows.forEach((row) => {
        const series = row[mapping.series] || "";
        const issue = row[mapping.issue] || "";
        if (!series && !issue) return;

        const idKey = `${series}::${issue}`.toLowerCase();
        const exists = state.collection.some((c) => `${c.series}::${c.issue}`.toLowerCase() === idKey);
        if (exists) {
          skipped += 1;
          return;
        }

        state.collection.push({
          id: idKey,
          series,
          issue,
          coverDate: mapping.coverDate ? row[mapping.coverDate] : "",
          image: mapping.image ? row[mapping.image] : "",
          synopsis: mapping.synopsis ? row[mapping.synopsis] : (mapping.notes ? row[mapping.notes] : ""),
          notes: ""
        });
        added += 1;
      });

      storage.set("cv_collection_v1", state.collection);
      renderCollection();
      renderStats();
      els.importStatus.textContent = `Imported ${added}. Skipped ${skipped} duplicates.`;
    }

    function exportCsv() {
      if (!state.collection.length) {
        alert("No comics to export.");
        return;
      }
      const headers = ["Series", "Issue", "CoverDate", "Image", "Synopsis"];
      const rows = state.collection.map((item) => [
        escapeCsv(item.series),
        escapeCsv(item.issue),
        escapeCsv(item.coverDate),
        escapeCsv(item.image),
        escapeCsv(item.synopsis || item.notes || "")
      ]);
      const csv = [headers.join(","), ...rows.map((r) => r.join(","))].join("\n");
      const blob = new Blob([csv], { type: "text/csv" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "comic-vault-export.csv";
      a.click();
      URL.revokeObjectURL(url);
    }

    function parseCsv(text) {
      const rows = [];
      let headers = [];
      const lines = text.replace(/\r\n/g, "\n").split("\n").filter((line) => line.trim().length);
      if (!lines.length) return { headers, rows };

      headers = parseCsvLine(lines[0]);
      for (let i = 1; i < lines.length; i++) {
        const cols = parseCsvLine(lines[i]);
        const row = {};
        headers.forEach((h, idx) => {
          row[h] = cols[idx] ? cols[idx].trim() : "";
        });
        rows.push(row);
      }
      return { headers, rows };
    }

    function parseCsvLine(line) {
      const result = [];
      let current = "";
      let inQuotes = false;
      for (let i = 0; i < line.length; i++) {
        const char = line[i];
        const next = line[i + 1];
        if (char === '"' && next === '"') {
          current += '"';
          i++;
        } else if (char === '"') {
          inQuotes = !inQuotes;
        } else if (char === "," && !inQuotes) {
          result.push(current);
          current = "";
        } else {
          current += char;
        }
      }
      result.push(current);
      return result.map((v) => v.trim());
    }

    function mapHeaders(headers) {
      const normalized = headers.reduce((acc, h) => {
        acc[normalize(h)] = h;
        return acc;
      }, {});

      const find = (...keys) => keys.find((k) => normalized[k]) && normalized[keys.find((k) => normalized[k])];

      return {
        series: find("series", "title", "volume", "name"),
        issue: find("issue", "issue number", "number", "#"),
        coverDate: find("coverdate", "cover date", "date", "year"),
        image: find("image", "cover", "thumbnail", "cover url"),
        synopsis: find("synopsis", "summary"),
        notes: find("notes", "description", "desc")
      };
    }

    function normalize(value) {
      return value.toLowerCase().replace(/[^a-z0-9]+/g, " ").trim();
    }

    function escapeHtml(str) {
      return String(str).replace(/[&<>"']/g, (c) => ({
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      })[c]);
    }

    function escapeCsv(value) {
      const str = String(value ?? "");
      if (/[",\n]/.test(str)) {
        return '"' + str.replace(/"/g, '""') + '"';
      }
      return str;
    }

    function stripHtml(html) {
      const temp = document.createElement("div");
      temp.innerHTML = html;
      return temp.textContent || temp.innerText || "";
    }

    function truncate(str, len) {
      if (str.length <= len) return str;
      return str.slice(0, len - 1) + "â€¦";
    }
  </script>
</body>
</html>
