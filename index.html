<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Comic Vault - Simple Collection Manager</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet" />
  <style>
    :root {
      --bg: #0e1016;
      --panel: #141824;
      --panel-2: #1b2131;
      --accent: #ff5c3a;
      --accent-2: #ffe082;
      --text: #f4f6fb;
      --muted: #9aa4b2;
      --good: #42d392;
      --bad: #ff6b6b;
      --border: #2a3144;
      --shadow: 0 20px 50px rgba(0,0,0,0.35);
      --radius: 14px;
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Space Grotesk", sans-serif;
      color: var(--text);
      background:
        radial-gradient(1200px 800px at 10% -20%, rgba(255,92,58,0.18), transparent 60%),
        radial-gradient(900px 700px at 100% 0%, rgba(255,224,130,0.12), transparent 55%),
        linear-gradient(180deg, #0c0f14 0%, #101521 100%);
      min-height: 100vh;
    }

    header {
      padding: 28px 24px 14px;
      display: flex;
      gap: 24px;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
    }

    .brand {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .title {
      font-size: 28px;
      font-weight: 700;
      letter-spacing: 0.5px;
    }

    .subtitle {
      color: var(--muted);
      font-size: 14px;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 18px;
      padding: 0 24px 24px;
    }

    .card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 18px;
      box-shadow: var(--shadow);
    }

    .card h2 {
      margin: 0 0 12px;
      font-size: 18px;
      font-weight: 600;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-bottom: 12px;
    }

    label {
      font-size: 12px;
      color: var(--muted);
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    input, textarea, select {
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--panel-2);
      color: var(--text);
      font-family: inherit;
      font-size: 14px;
    }

    textarea { min-height: 80px; resize: vertical; }

    button {
      background: var(--accent);
      border: none;
      color: #0b0d12;
      font-weight: 700;
      padding: 10px 16px;
      border-radius: 12px;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    button.secondary {
      background: transparent;
      color: var(--text);
      border: 1px solid var(--border);
    }

    button:active { transform: translateY(1px); }

    .row {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    .status {
      font-family: "IBM Plex Mono", monospace;
      font-size: 12px;
      color: var(--muted);
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.06);
      color: var(--muted);
      font-size: 12px;
    }

    .results, .collection {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
      max-height: 420px;
      overflow: auto;
      padding-right: 6px;
    }

    .comic {
      background: #111624;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px;
      display: grid;
      grid-template-columns: 70px 1fr;
      gap: 10px;
    }

    .comic img {
      width: 70px;
      height: 100px;
      object-fit: cover;
      border-radius: 8px;
      border: 1px solid var(--border);
    }

    .comic h3 {
      margin: 0 0 6px;
      font-size: 14px;
    }

    .comic p {
      margin: 0;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.4;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 10px;
    }

    .stat {
      background: #111624;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
    }

    .stat .value {
      font-size: 20px;
      font-weight: 700;
    }

    .muted { color: var(--muted); }
    .good { color: var(--good); }
    .bad { color: var(--bad); }

    footer {
      padding: 0 24px 32px;
      color: var(--muted);
      font-size: 12px;
    }

    @media (max-width: 720px) {
      header { padding: 20px 18px 10px; }
      .grid { padding: 0 18px 18px; }
    }
  </style>
</head>
<body>
  <header>
    <div class="brand">
      <div class="title">Comic Vault</div>
      <div class="subtitle">Single-file comic collection manager. No backend, no hassle.</div>
    </div>
    <div class="row">
      <span class="badge">Local storage</span>
      <span class="badge">ComicVine API</span>
      <span class="badge">CSV import/export</span>
    </div>
  </header>

  <main class="grid">
    <section class="card">
      <h2>API Setup</h2>
      <div class="field">
        <label for="apiKey">ComicVine API Key</label>
        <input id="apiKey" placeholder="Paste your API key" />
      </div>
      <div class="row">
        <button id="saveKey">Save Key</button>
        <button id="clearKey" class="secondary">Clear Key</button>
      </div>
      <p class="status" id="apiStatus">Waiting for API key.</p>
      <p class="muted">No API URL needed. This uses the ComicVine API through a CORS proxy automatically.</p>
    </section>

    <section class="card">
      <h2>Search ComicVine</h2>
      <div class="field">
        <label for="query">Search</label>
        <input id="query" placeholder="Batman, X-Men, Saga..." />
      </div>
      <div class="row">
        <button id="searchBtn">Search Issues</button>
        <button id="clearSearch" class="secondary">Clear</button>
      </div>
      <p class="status" id="searchStatus">Ready.</p>
      <div class="results" id="results"></div>
    </section>

    <section class="card">
      <h2>Your Collection</h2>
      <div class="row">
        <button id="exportCsv">Export CSV</button>
        <button id="clearCollection" class="secondary">Clear Collection</button>
      </div>
      <div class="collection" id="collection"></div>
    </section>

    <section class="card">
      <h2>Import CSV</h2>
      <div class="field">
        <label for="csvInput">CSV File</label>
        <input id="csvInput" type="file" accept=".csv" />
      </div>
      <div class="field">
        <label for="csvPreview">Detected Columns</label>
        <textarea id="csvPreview" readonly></textarea>
      </div>
      <div class="row">
        <button id="importCsv">Import</button>
        <button id="resetImport" class="secondary">Reset</button>
      </div>
      <p class="status" id="importStatus">Waiting for CSV.</p>
    </section>

    <section class="card">
      <h2>Stats</h2>
      <div class="stats" id="stats"></div>
    </section>
  </main>

  <footer>
    Built to keep it simple. Data is stored only in your browser (localStorage).
  </footer>

  <script>
    const storage = {
      get(key, fallback) {
        try {
          const raw = localStorage.getItem(key);
          return raw ? JSON.parse(raw) : fallback;
        } catch {
          return fallback;
        }
      },
      set(key, value) {
        localStorage.setItem(key, JSON.stringify(value));
      },
      remove(key) {
        localStorage.removeItem(key);
      }
    };

    const state = {
      apiKey: storage.get("cv_api_key", ""),
      collection: storage.get("cv_collection_v1", []),
      csvRows: [],
      csvHeaders: []
    };

    const els = {
      apiKey: document.getElementById("apiKey"),
      apiStatus: document.getElementById("apiStatus"),
      saveKey: document.getElementById("saveKey"),
      clearKey: document.getElementById("clearKey"),
      query: document.getElementById("query"),
      searchBtn: document.getElementById("searchBtn"),
      clearSearch: document.getElementById("clearSearch"),
      results: document.getElementById("results"),
      searchStatus: document.getElementById("searchStatus"),
      collection: document.getElementById("collection"),
      exportCsv: document.getElementById("exportCsv"),
      clearCollection: document.getElementById("clearCollection"),
      csvInput: document.getElementById("csvInput"),
      csvPreview: document.getElementById("csvPreview"),
      importCsv: document.getElementById("importCsv"),
      resetImport: document.getElementById("resetImport"),
      importStatus: document.getElementById("importStatus"),
      stats: document.getElementById("stats")
    };

    els.apiKey.value = state.apiKey;
    updateApiStatus();
    renderCollection();
    renderStats();

    els.saveKey.addEventListener("click", () => {
      state.apiKey = els.apiKey.value.trim();
      storage.set("cv_api_key", state.apiKey);
      updateApiStatus();
    });

    els.clearKey.addEventListener("click", () => {
      state.apiKey = "";
      els.apiKey.value = "";
      storage.remove("cv_api_key");
      updateApiStatus();
    });

    els.searchBtn.addEventListener("click", () => searchIssues());
    els.clearSearch.addEventListener("click", () => {
      els.query.value = "";
      els.results.innerHTML = "";
      els.searchStatus.textContent = "Cleared.";
    });

    els.exportCsv.addEventListener("click", () => exportCsv());
    els.clearCollection.addEventListener("click", () => {
      if (!confirm("Clear your entire collection?")) return;
      state.collection = [];
      storage.set("cv_collection_v1", state.collection);
      renderCollection();
      renderStats();
    });

    els.csvInput.addEventListener("change", handleCsvFile);
    els.importCsv.addEventListener("click", importCsv);
    els.resetImport.addEventListener("click", () => {
      els.csvInput.value = "";
      els.csvPreview.value = "";
      state.csvRows = [];
      state.csvHeaders = [];
      els.importStatus.textContent = "Waiting for CSV.";
    });

    async function searchIssues() {
      if (!state.apiKey) {
        els.searchStatus.textContent = "Add your ComicVine API key first.";
        return;
      }
      const query = els.query.value.trim();
      if (!query) {
        els.searchStatus.textContent = "Enter a search term.";
        return;
      }

      els.searchStatus.textContent = "Searching...";
      els.results.innerHTML = "";

      const base = "https://comicvine.gamespot.com/api";
      const params = new URLSearchParams({
        api_key: state.apiKey,
        format: "json",
        resources: "issue",
        query,
        limit: "20",
        field_list: "id,name,issue_number,cover_date,image,volume,description"
      });
      const targetUrl = `${base}/search/?${params.toString()}`;
      const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`;

      try {
        const res = await fetch(proxyUrl);
        const data = await res.json();
        if (data.error && data.error !== "OK") {
          throw new Error(data.error);
        }
        const results = data.results || [];
        if (!results.length) {
          els.searchStatus.textContent = "No results.";
          return;
        }
        els.searchStatus.textContent = `Found ${results.length} issues.`;
        renderResults(results);
      } catch (err) {
        els.searchStatus.textContent = `Search failed: ${err.message}`;
      }
    }

    function renderResults(results) {
      els.results.innerHTML = "";
      results.forEach((item) => {
        const card = document.createElement("div");
        card.className = "comic";
        const img = item.image?.small_url || "";
        card.innerHTML = `
          <img src="${img}" alt="${escapeHtml(item.name || "Issue")}" />
          <div>
            <h3>${escapeHtml(item.volume?.name || item.name || "Unknown")}</h3>
            <p>Issue #${escapeHtml(item.issue_number || "?")}</p>
            <p>${escapeHtml(item.cover_date || "")}</p>
            <p>${truncate(stripHtml(item.description || ""), 80)}</p>
            <div class="row" style="margin-top:8px;">
              <button data-add="${item.id}">Add</button>
            </div>
          </div>
        `;
        card.querySelector("button").addEventListener("click", () => addToCollection(item));
        els.results.appendChild(card);
      });
    }

    function addToCollection(item) {
      const exists = state.collection.some((c) => c.id === item.id);
      if (exists) {
        els.searchStatus.textContent = "Already in collection.";
        return;
      }
      const entry = {
        id: item.id,
        series: item.volume?.name || item.name || "Unknown",
        issue: item.issue_number || "",
        coverDate: item.cover_date || "",
        image: item.image?.small_url || "",
        notes: ""
      };
      state.collection.unshift(entry);
      storage.set("cv_collection_v1", state.collection);
      renderCollection();
      renderStats();
      els.searchStatus.textContent = "Added to collection.";
    }

    function renderCollection() {
      els.collection.innerHTML = "";
      if (!state.collection.length) {
        els.collection.innerHTML = "<p class='muted'>No comics yet.</p>";
        return;
      }
      state.collection.forEach((item, index) => {
        const card = document.createElement("div");
        card.className = "comic";
        card.innerHTML = `
          <img src="${item.image || ""}" alt="${escapeHtml(item.series)}" />
          <div>
            <h3>${escapeHtml(item.series)}</h3>
            <p>Issue #${escapeHtml(item.issue || "?")}</p>
            <p>${escapeHtml(item.coverDate || "")}</p>
            <div class="row" style="margin-top:8px;">
              <button data-remove="${index}" class="secondary">Remove</button>
            </div>
          </div>
        `;
        card.querySelector("button").addEventListener("click", () => {
          state.collection.splice(index, 1);
          storage.set("cv_collection_v1", state.collection);
          renderCollection();
          renderStats();
        });
        els.collection.appendChild(card);
      });
    }

    function renderStats() {
      const total = state.collection.length;
      const seriesSet = new Set(state.collection.map((c) => c.series));
      const years = state.collection
        .map((c) => (c.coverDate || "").slice(0, 4))
        .filter((y) => y && /^\d{4}$/.test(y));
      const yearCounts = years.reduce((acc, y) => {
        acc[y] = (acc[y] || 0) + 1;
        return acc;
      }, {});
      const topYear = Object.entries(yearCounts).sort((a, b) => b[1] - a[1])[0];

      els.stats.innerHTML = "";
      const statItems = [
        { label: "Total Issues", value: total },
        { label: "Series", value: seriesSet.size },
        { label: "Top Year", value: topYear ? `${topYear[0]} (${topYear[1]})` : "-" }
      ];

      statItems.forEach((stat) => {
        const div = document.createElement("div");
        div.className = "stat";
        div.innerHTML = `<div class="muted">${stat.label}</div><div class="value">${stat.value}</div>`;
        els.stats.appendChild(div);
      });
    }

    function updateApiStatus() {
      if (state.apiKey) {
        els.apiStatus.textContent = "API key saved.";
        els.apiStatus.className = "status good";
      } else {
        els.apiStatus.textContent = "Waiting for API key.";
        els.apiStatus.className = "status";
      }
    }

    function handleCsvFile(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = () => {
        const text = reader.result;
        const { headers, rows } = parseCsv(text);
        state.csvHeaders = headers;
        state.csvRows = rows;
        els.csvPreview.value = headers.length ? headers.join(", ") : "No headers detected.";
        els.importStatus.textContent = `Loaded ${rows.length} rows.`;
      };
      reader.readAsText(file);
    }

    function importCsv() {
      if (!state.csvRows.length) {
        els.importStatus.textContent = "Load a CSV file first.";
        return;
      }

      const mapping = mapHeaders(state.csvHeaders);
      if (!mapping.series || !mapping.issue) {
        els.importStatus.textContent = "CSV needs columns for Series/Title and Issue.";
        return;
      }

      let added = 0;
      let skipped = 0;

      state.csvRows.forEach((row) => {
        const series = row[mapping.series] || "";
        const issue = row[mapping.issue] || "";
        if (!series && !issue) return;

        const idKey = `${series}::${issue}`.toLowerCase();
        const exists = state.collection.some((c) => `${c.series}::${c.issue}`.toLowerCase() === idKey);
        if (exists) {
          skipped += 1;
          return;
        }

        state.collection.push({
          id: idKey,
          series,
          issue,
          coverDate: mapping.coverDate ? row[mapping.coverDate] : "",
          image: mapping.image ? row[mapping.image] : "",
          notes: mapping.notes ? row[mapping.notes] : ""
        });
        added += 1;
      });

      storage.set("cv_collection_v1", state.collection);
      renderCollection();
      renderStats();
      els.importStatus.textContent = `Imported ${added}. Skipped ${skipped} duplicates.`;
    }

    function exportCsv() {
      if (!state.collection.length) {
        alert("No comics to export.");
        return;
      }
      const headers = ["Series", "Issue", "CoverDate", "Image", "Notes"];
      const rows = state.collection.map((item) => [
        escapeCsv(item.series),
        escapeCsv(item.issue),
        escapeCsv(item.coverDate),
        escapeCsv(item.image),
        escapeCsv(item.notes)
      ]);
      const csv = [headers.join(","), ...rows.map((r) => r.join(","))].join("\n");
      const blob = new Blob([csv], { type: "text/csv" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "comic-vault-export.csv";
      a.click();
      URL.revokeObjectURL(url);
    }

    function parseCsv(text) {
      const rows = [];
      let headers = [];
      const lines = text.replace(/\r\n/g, "\n").split("\n").filter((line) => line.trim().length);
      if (!lines.length) return { headers, rows };

      headers = parseCsvLine(lines[0]);
      for (let i = 1; i < lines.length; i++) {
        const cols = parseCsvLine(lines[i]);
        const row = {};
        headers.forEach((h, idx) => {
          row[h] = cols[idx] ? cols[idx].trim() : "";
        });
        rows.push(row);
      }
      return { headers, rows };
    }

    function parseCsvLine(line) {
      const result = [];
      let current = "";
      let inQuotes = false;
      for (let i = 0; i < line.length; i++) {
        const char = line[i];
        const next = line[i + 1];
        if (char === '"' && next === '"') {
          current += '"';
          i++;
        } else if (char === '"') {
          inQuotes = !inQuotes;
        } else if (char === "," && !inQuotes) {
          result.push(current);
          current = "";
        } else {
          current += char;
        }
      }
      result.push(current);
      return result.map((v) => v.trim());
    }

    function mapHeaders(headers) {
      const normalized = headers.reduce((acc, h) => {
        acc[normalize(h)] = h;
        return acc;
      }, {});

      const find = (...keys) => keys.find((k) => normalized[k]) && normalized[keys.find((k) => normalized[k])];

      return {
        series: find("series", "title", "volume", "name"),
        issue: find("issue", "issue number", "number", "#"),
        coverDate: find("coverdate", "cover date", "date", "year"),
        image: find("image", "cover", "thumbnail", "cover url"),
        notes: find("notes", "description", "desc")
      };
    }

    function normalize(value) {
      return value.toLowerCase().replace(/[^a-z0-9]+/g, " ").trim();
    }

    function escapeHtml(str) {
      return String(str).replace(/[&<>"']/g, (c) => ({
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      })[c]);
    }

    function escapeCsv(value) {
      const str = String(value ?? "");
      if (/[",\n]/.test(str)) {
        return '"' + str.replace(/"/g, '""') + '"';
      }
      return str;
    }

    function stripHtml(html) {
      const temp = document.createElement("div");
      temp.innerHTML = html;
      return temp.textContent || temp.innerText || "";
    }

    function truncate(str, len) {
      if (str.length <= len) return str;
      return str.slice(0, len - 1) + "â€¦";
    }
  </script>
</body>
</html>
